<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<script src="UM-1.2.0.js"></script>
</head>
<body>
	<input type="file" id="aaa">
	<div style="background:red; width:200px; height:50px; text-align:center; line-height:50px; cursor:pointer" id="bbb">显示</div>
</body>
<script>
function condense(json){
	let file=json.file;
	let maxWidth=json.maxWidth || null;
	let maxHeight=json.maxHeight || null;
	let quality=json.quality || null;
	let type=json.type || 'image/png';

	if(!HTMLCanvasElement.prototype.toBlob){    // 如果canvas对象没有toBlob方法原型, 则加上(即兼容低版本浏览器)
	    Object.defineProperty(HTMLCanvasElement.prototype, 'toBlob', {
	        value: function(callback, type, quality){
	            let _this=this;
	            setTimeout(function(){
	                let binStr=atob(_this.toDataURL(type, quality).split(',')[1]);
	                let len=binStr.length;
	                let arr=new Uint8Array(len);

	                for(let i=0; i<len; i++){
	                    arr[i]=binStr.charCodeAt(i);
	                };

	                callback(new Blob([arr], {type:type || 'image/png'}));
	            });
	        }
	    });
	}

	if(_isArray(file)){    // 判断file是否是一个数组
		let um_imgArr=[];
		let um_promiseArr=[];

		file.forEach(val=>{
			let um_json={};

			um_json.file=val;
			um_json.img=new Image();
			um_json.reader=new FileReader();
			um_json.canvas=document.createElement('canvas'); 
			um_json.context=um_json.canvas.getContext('2d');
			um_json.target_width=0;
			um_json.target_height=0;

			um_imgArr.push(um_json);
		});

		um_imgArr.forEach((val, i)=>{
			let promiseObj=new Promise((resolve, reject)=>{
				val.img.onload=function(){
				    // 图片原始尺寸
				    let originWidth = this.width;
				    let originHeight = this.height;

				    if((maxWidth && maxWidth>0) && (maxHeight && maxHeight>0)){
					    if(originWidth>maxWidth || originHeight>maxHeight){
					    	if(originWidth/originHeight>maxWidth/maxHeight){
					    		val.target_width=maxWidth;
					    		val.target_height=Math.ceil(maxWidth*(originHeight/originWidth));
					    	}else{
					    		val.target_width=Math.ceil(maxHeight*(originWidth/originHeight));
					    		val.target_height=maxHeight;
					    	};
					    }else{
					    	val.target_width=originWidth;
					    	val.target_height=originHeight;
					    };
				    }else if((maxWidth && maxWidth>0) && !maxHeight){
			    		val.target_width=maxWidth;
			    		val.target_height=Math.ceil(maxWidth*(originHeight/originWidth));
				    }else if(!maxWidth && (maxHeight && maxHeight>0)){
			    		val.target_width=Math.ceil(maxHeight*(originWidth/originHeight));
			    		val.target_height=maxHeight;
				    }else if(!maxWidth && !maxHeight){
				    	val.target_width=originWidth;
				    	val.target_height=originHeight;
				    };
				    // 指定画布大小
				    val.canvas.width=val.target_width;
				    val.canvas.height=val.target_height;
				    // 画布生成画面
				    val.context.drawImage(val.img, 0, 0, val.target_width, val.target_height);

				    if(quality){
					    val.canvas.toBlob(blob=>{
					    	resolve({_index:i, _file:blob});
					    }, 'image/jpeg', quality);
				    }else{
					    val.canvas.toBlob(blob=>{
					    	resolve({_index:i, _file:blob});
					    }, type);
				    };
				};

				val.reader.onload=function(){
				    val.img.src=this.result;
				};

				val.reader.readAsDataURL(val.file);
			});

			um_promiseArr.push(promiseObj);
		});
		
		return new Promise((resolve, reject)=>{
			Promise.all(um_promiseArr).then(data=>{
				data.sort((obj1, obj2)=>{
					let n1=obj1._index;
					let n2=obj2._index;
					return n1-n2;
				});
				data.forEach((val, i, arr)=>{
					arr[i]=val._file;
				});
				resolve(data);
			}).catch(err=>{
				reject(err);
			});
		});
	}else{
		return new Promise((resolve, reject)=>{
			let reader=new FileReader();
			let img=new Image();

			let canvas=document.createElement('canvas');
			let context=canvas.getContext('2d');

			let target_width=0;
			let target_height=0;

			img.onload=function(){
			    // 图片原始尺寸
			    let originWidth = this.width;
			    let originHeight = this.height;

			    if((maxWidth && maxWidth>0) && (maxHeight && maxHeight>0)){
				    if(originWidth>maxWidth || originHeight>maxHeight){
				    	if(originWidth/originHeight>maxWidth/maxHeight){
				    		target_width=maxWidth;
				    		target_height=Math.ceil(maxWidth*(originHeight/originWidth));
				    	}else{
				    		target_width=Math.ceil(maxHeight*(originWidth/originHeight));
				    		target_height=maxHeight;
				    	};
				    }else{
				    	target_width=originWidth;
				    	target_height=originHeight;
				    };
			    }else if((maxWidth && maxWidth>0) && !maxHeight){
		    		target_width=maxWidth;
		    		target_height=Math.ceil(maxWidth*(originHeight/originWidth));
			    }else if(!maxWidth && (maxHeight && maxHeight>0)){
		    		target_width=Math.ceil(maxHeight*(originWidth/originHeight));
		    		target_height=maxHeight;
			    }else if(!maxWidth && !maxHeight){
			    	target_width=originWidth;
			    	target_height=originHeight;
			    };
			    // 指定画布大小
			    canvas.width=target_width;
			    canvas.height=target_height;
			    // 画布生成画面
			    context.drawImage(img, 0, 0, target_width, target_height);

			    if(quality){
		    		canvas.toBlob(blob=>{
		    			resolve(blob);
		    		}, 'image/jpeg', quality);
			    }else{
		    		canvas.toBlob(blob=>{
		    			resolve(blob);
		    		}, type);
			    };
			};

			reader.onload=function(){
			    img.src=this.result;
			};

			reader.readAsDataURL(file);
		});
	};
};

/*condense({      // 压缩图片插件
	file:xxx.files[0],      // 要压缩的文件 或者 文件数组
	maxWidth:400,	// 压缩最大宽度, 如果原图片宽度超过该值则压缩至该值
	maxHeight:400,	// 压缩最大高度, 如果原图片高度超过该值则压缩至该值
	quality:.7,   // 压缩品质 最大1
	type:'image/jpeg'  // 压缩格式
}).then(blob=>{   // 回调函数的参数blob即为已压缩好的二进制文件 或者 二进制文件数组(*注: 如果file参数是文件, 则blob是一个二进制文件; 如果file参数是文件数组, 则blob是一个二进制文件数组)
	// todo...
}).catch(err=>{
	// todo...
});*/

let arr=[];
let result=[];

aaa.onchange=function(){
	if(this.files.length>0)arr.push(this.files[0]);
};

document.ondblclick=function(){
	condense({
		file:arr,
		quality:.1
	}).then(blobArr=>{
		console.log(blobArr);
	});
}

bbb.onclick=function(){
	console.log(arr);
	console.log(result);
};
</script>
</html>